import { Subscription } from '../subscriptions';
import { Wallet } from '../wallet';
import { Sync, Transaction, TransactionReceipt, Log, GetLogOptions } from '../formatters';
import { TransactionHash } from '../types';
import { Data, Address, Quantity } from '../types';
import { PromiEvent, PromiEventResult } from '../promievent';
import { EthRequestPayloads } from './eth-request-payloads';
import { Block, BlockHeader, BlockType, BlockHash } from './block';
import { Tx, SignedTransaction } from './tx';
import { EthereumProvider } from '../providers/ethereum-provider';
export declare type TypedSigningData = {
    type: string;
    name: string;
    value: string;
}[];
export interface SendTxPromiEvent<TxReceipt = TransactionReceipt> extends PromiEvent<TxReceipt> {
    once(type: 'transactionHash', handler: (transactionHash: string) => void): this;
    once(type: 'receipt', handler: (receipt: TxReceipt) => void): this;
    once(type: 'confirmation', handler: (confNumber: number, receipt: TxReceipt) => void): this;
    once(type: 'error', handler: (error: Error) => void): this;
    on(type: 'transactionHash', handler: (transactionHash: string) => void): this;
    on(type: 'receipt', handler: (receipt: TxReceipt) => void): this;
    on(type: 'confirmation', handler: (confNumber: number, receipt: TxReceipt) => void): this;
    on(type: 'error', handler: (error: Error) => void): this;
}
export declare class Eth {
    readonly provider: EthereumProvider;
    readonly request: EthRequestPayloads;
    private wallet?;
    constructor(provider: EthereumProvider);
    setWallet(wallet?: Wallet): void;
    getDefaultFromAddress(): string | undefined;
    setDefaultFromAddress(address?: string): void;
    private send;
    getId(): Promise<number>;
    getNodeInfo(): Promise<string>;
    getProtocolVersion(): Promise<string>;
    getCoinbase(): Promise<Address>;
    isMining(): Promise<boolean>;
    getHashrate(): Promise<number>;
    isSyncing(): Promise<Sync | boolean>;
    getGasPrice(): Promise<Quantity>;
    getAccounts(): Promise<Address[]>;
    getBlockNumber(): Promise<number>;
    getBalance(address: Address, block?: BlockType): Promise<Quantity>;
    getStorageAt(address: Address, position: string, block?: BlockType): Promise<Data>;
    getCode(address: Address, block?: BlockType): Promise<Data>;
    getBlock(block: BlockType | BlockHash, returnTransactionObjects?: boolean): Promise<Block>;
    getUncle(block: BlockType | BlockHash, uncleIndex: number, returnTransactionObjects?: boolean): Promise<Block>;
    getBlockTransactionCount(block: BlockType | BlockHash): Promise<number>;
    getBlockUncleCount(block: BlockType | BlockHash): Promise<number>;
    getTransaction(hash: TransactionHash): Promise<Transaction>;
    getTransactionFromBlock(block: BlockType | BlockHash, index: number): Promise<Transaction>;
    getTransactionReceipt(hash: TransactionHash): Promise<TransactionReceipt>;
    getTransactionCount(address: Address, block?: BlockType): Promise<number>;
    signTransaction(tx: Tx): Promise<SignedTransaction>;
    sendSignedTransaction(data: Data, extraFormatters?: any, defer?: PromiEventResult<TransactionReceipt>): SendTxPromiEvent;
    sendTransaction(tx: Tx, extraFormatters?: any): SendTxPromiEvent;
    private getAccount;
    private sendTransactionAsync;
    private sendTransactionAndWaitForConfirmation;
    sign(address: Address, dataToSign: Data): Promise<Data>;
    signTypedData(address: Address, dataToSign: TypedSigningData): Promise<Data>;
    call(tx: Tx, block?: BlockType, outputFormatter?: (result: any) => any): Promise<Data>;
    estimateGas(tx: Tx): Promise<number>;
    submitWork(nonce: string, powHash: string, digest: string): Promise<boolean>;
    getWork(): Promise<string[]>;
    getPastLogs(options: GetLogOptions): Promise<Log[]>;
    subscribeLogs(options?: GetLogOptions): Subscription<Log>;
    subscribeSyncing(): Subscription<object | boolean>;
    subscribeNewBlockHeaders(): Subscription<BlockHeader>;
    subscribePendingTransactions(): Subscription<Transaction>;
    subscribe(type: 'logs', options?: GetLogOptions): Subscription<Log>;
    subscribe(type: 'syncing'): Subscription<object | boolean>;
    subscribe(type: 'newBlockHeaders'): Subscription<BlockHeader>;
    subscribe(type: 'pendingTransactions'): Subscription<Transaction>;
}
