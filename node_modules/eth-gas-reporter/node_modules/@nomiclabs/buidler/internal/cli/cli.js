#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line
// tslint:disable-next-line
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const semver_1 = __importDefault(require("semver"));
require("source-map-support/register");
const task_names_1 = require("../../builtin-tasks/task-names");
const constants_1 = require("../constants");
const context_1 = require("../context");
const config_loading_1 = require("../core/config/config-loading");
const errors_1 = require("../core/errors");
const buidler_params_1 = require("../core/params/buidler-params");
const env_variables_1 = require("../core/params/env-variables");
const project_structure_1 = require("../core/project-structure");
const runtime_environment_1 = require("../core/runtime-environment");
const typescript_support_1 = require("../core/typescript-support");
const packageInfo_1 = require("../util/packageInfo");
const ArgumentsParser_1 = require("./ArgumentsParser");
const emoji_1 = require("./emoji");
const project_creation_1 = require("./project-creation");
async function printVersionMessage(packageJson) {
    console.log(packageJson.version);
}
function ensureValidNodeVersion(packageJson) {
    const requirement = packageJson.engines.node;
    if (!semver_1.default.satisfies(process.version, requirement)) {
        throw new errors_1.BuidlerError(errors_1.ERRORS.GENERAL.INVALID_NODE_VERSION, requirement);
    }
}
async function main() {
    // We first accept this argument anywhere, so we know if the user wants
    // stack traces before really parsing the arguments.
    let showStackTraces = process.argv.includes("--show-stack-traces");
    try {
        const packageJson = await packageInfo_1.getPackageJson();
        ensureValidNodeVersion(packageJson);
        const envVariableArguments = env_variables_1.getEnvBuidlerArguments(buidler_params_1.BUIDLER_PARAM_DEFINITIONS, process.env);
        const argumentsParser = new ArgumentsParser_1.ArgumentsParser();
        const { buidlerArguments, taskName: parsedTaskName, unparsedCLAs } = argumentsParser.parseBuidlerArguments(buidler_params_1.BUIDLER_PARAM_DEFINITIONS, envVariableArguments, process.argv.slice(2));
        if (buidlerArguments.emoji) {
            emoji_1.enableEmoji();
        }
        showStackTraces = buidlerArguments.showStackTraces;
        if (buidlerArguments.config === undefined &&
            !project_structure_1.isCwdInsideProject() &&
            process.stdout.isTTY === true) {
            await project_creation_1.createProject();
            return;
        }
        // --version is a special case
        if (buidlerArguments.version) {
            await printVersionMessage(packageJson);
            return;
        }
        typescript_support_1.loadTsNodeIfPresent();
        const ctx = context_1.BuidlerContext.createBuidlerContext();
        const config = config_loading_1.loadConfigAndTasks(buidlerArguments.config);
        const envExtenders = ctx.extendersManager.getExtenders();
        const taskDefinitions = ctx.tasksDSL.getTaskDefinitions();
        const taskName = parsedTaskName !== undefined ? parsedTaskName : "help";
        const taskDefinition = taskDefinitions[taskName];
        if (taskDefinition === undefined) {
            throw new errors_1.BuidlerError(errors_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, taskName);
        }
        const taskArguments = argumentsParser.parseTaskArguments(taskDefinition, unparsedCLAs);
        const env = new runtime_environment_1.Environment(config, buidlerArguments, taskDefinitions, envExtenders);
        ctx.setBuidlerRuntimeEnvironment(env);
        // --help is a also special case
        if (buidlerArguments.help && taskName !== task_names_1.TASK_HELP) {
            await env.run(task_names_1.TASK_HELP, { task: taskName });
            return;
        }
        await env.run(taskName, taskArguments);
    }
    catch (error) {
        let isBuidlerError = false;
        if (error instanceof errors_1.BuidlerError) {
            isBuidlerError = true;
            console.error(ansi_colors_1.default.red("Error " + error.message));
        }
        else if (error instanceof errors_1.BuidlerPluginError) {
            isBuidlerError = true;
            console.error(ansi_colors_1.default.red("Error in plugin " + error.pluginName + ": " + error.message));
        }
        else if (error instanceof Error) {
            console.error(ansi_colors_1.default.red("An unexpected error occurred: " + error.message));
        }
        else {
            console.error(ansi_colors_1.default.red("An unexpected error occurred."));
        }
        console.log("");
        if (showStackTraces) {
            console.error(error.stack);
        }
        else {
            if (!isBuidlerError) {
                console.error(`This shouldn't have happened, please report it to help us improve ${constants_1.BUIDLER_NAME}.`);
            }
            console.error(`For more info run ${constants_1.BUIDLER_NAME} with --show-stack-traces.`);
        }
        process.exit(1);
    }
}
main()
    .then(() => process.exit(0))
    .catch(error => {
    console.error(error);
    process.exit(1);
});
//# sourceMappingURL=cli.js.map