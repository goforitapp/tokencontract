import { Subscription } from '../subscriptions';
import { Tx } from './tx';
import { EventLog, GetLogOptions } from '../formatters';
import { TxDeploy } from './tx-deploy';
import { ContractAbi } from './contract-abi';
import { Data } from '../types';
import { Eth } from '../eth';
import { Wallet } from '../wallet';
export interface ContractOptions {
    from?: string;
    gasPrice?: string;
    gas?: number;
}
interface ContractDefinition {
    methods: any;
    events?: any;
    eventLogs?: any;
}
export declare type EventSubscriptionFactory<Result = EventLog<any>> = (options?: object, callback?: (err: Error, result: Result, subscription: Subscription<Result>) => void) => Subscription<Result>;
declare type Events<T extends ContractDefinition | void> = T extends ContractDefinition ? Extract<keyof T['events'], string> : string;
declare type GetEventLog<T extends ContractDefinition | void, P extends Events<T>> = T extends ContractDefinition ? T['eventLogs'][P] : EventLog<any>;
declare type GetContractMethods<T> = T extends ContractDefinition ? T['methods'] : {
    [key: string]: (...args: any[]) => Tx;
};
declare type GetContractEvents<T> = T extends ContractDefinition ? T['events'] & {
    allEvents: EventSubscriptionFactory<T['eventLogs'][Events<T>]>;
} : {
    [key: string]: EventSubscriptionFactory;
};
/**
 * Should be called to create new contract instance
 *
 * @method Contract
 * @constructor
 * @param {Array} jsonInterface
 * @param {String} address
 * @param {Object} options
 */
export declare class Contract<T extends ContractDefinition | void = void> {
    private eth;
    private jsonInterface;
    address?: string | undefined;
    private wallet?;
    readonly methods: GetContractMethods<T>;
    readonly events: GetContractEvents<T>;
    private options;
    private extraFormatters;
    constructor(eth: Eth, jsonInterface: ContractAbi, address?: string | undefined, defaultOptions?: ContractOptions, wallet?: Wallet | undefined);
    /**
     * Deploys a contract and fire events based on its state: transactionHash, receipt
     * contract.deploy(data, 1, 2).send({ from: 0x123... });
     *
     * All event listeners will be removed, once the last possible event is fired ("error", or "receipt")
     */
    deploy(data: Data, ...args: any[]): TxDeploy;
    once<Event extends Events<T>>(event: Event, options: {
        filter?: object;
        topics?: string[];
    }, callback: (err: any, res: GetEventLog<T, Event>, sub: any) => void): any;
    /**
     * Adds event listeners and creates a subscription.
     */
    private on;
    /**
     * Get past events from contracts
     *
     * @method getPastEvents
     * @param {String} event
     * @param {Object} options
     * @param {Function} callback
     * @return {Object} the promievent
     */
    getPastEvents<Event extends Events<T>>(event: Event, options: GetLogOptions): Promise<GetEventLog<T, Event>[]>;
    getPastEvents(event: 'allevents', options: GetLogOptions): Promise<EventLog<any>[]>;
    private executorFactory;
    private setAddress;
    private getMethods;
    private getEvents;
    private getEnrichedAbiDefinition;
    /**
     * Should be used to encode indexed params and options to one final object
     *
     * @method _encodeEventABI
     * @param {Object} event
     * @param {Object} options
     * @return {Object} everything combined together and encoded
     */
    private getEventTopics;
    /**
     * Gets the event signature and outputformatters
     */
    private getLogOptions;
    private contractDeployFormatter;
    private receiptFormatter;
}
export {};
