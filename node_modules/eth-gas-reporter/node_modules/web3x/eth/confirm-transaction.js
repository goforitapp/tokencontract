"use strict";
/*
  This file is part of web3x.

  web3x is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  web3x is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with web3x.  If not, see <http://www.gnu.org/licenses/>.
*/
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const util_1 = require("util");
const TIMEOUTBLOCK = 50;
const POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK
const CONFIRMATIONBLOCKS = 24;
class UnminedError extends Error {
}
function confirmTransaction(defer, result, payload, eth, extraFormatters) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let promiseResolved = false;
        let canUnsubscribe = true;
        let timeoutCount = 0;
        let confirmationCount = 0;
        let intervalId = null;
        let receiptJSON = '';
        let gasProvided = util_1.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null;
        let isContractDeployment = util_1.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to;
        // fire "receipt" and confirmation events and resolve after
        var checkConfirmation = function (existingReceipt, isPolling, sub) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // create fake unsubscribe
                if (!sub) {
                    sub = {
                        unsubscribe: function () {
                            clearInterval(intervalId);
                        },
                    };
                }
                let receipt = existingReceipt;
                if (!receipt) {
                    try {
                        receipt = yield eth.getTransactionReceipt(result);
                    }
                    catch (err) {
                        sub.unsubscribe();
                        promiseResolved = true;
                        utils_1.fireError({ message: 'Failed to check for transaction receipt:', data: err }, defer.eventEmitter, defer.reject);
                    }
                }
                try {
                    // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false
                    {
                        if (!receipt || !receipt.blockHash) {
                            throw new UnminedError('Receipt missing or blockHash null');
                        }
                        // apply extra formatters
                        if (extraFormatters && extraFormatters.receiptFormatter) {
                            receipt = extraFormatters.receiptFormatter(receipt);
                        }
                        // check if confirmation listener exists
                        if (defer.eventEmitter.listeners('confirmation').length > 0) {
                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt);
                            canUnsubscribe = false;
                            confirmationCount++;
                            if (confirmationCount === CONFIRMATIONBLOCKS + 1) {
                                // add 1 so we account for conf 0
                                sub.unsubscribe();
                                defer.eventEmitter.removeAllListeners();
                            }
                        }
                    }
                    // CHECK for CONTRACT DEPLOYMENT
                    if (isContractDeployment && !promiseResolved) {
                        if (!receipt.contractAddress) {
                            if (canUnsubscribe) {
                                sub.unsubscribe();
                                promiseResolved = true;
                            }
                            utils_1.fireError(new Error("The transaction receipt didn't contain a contract address."), defer.eventEmitter, defer.reject);
                            return;
                        }
                        const code = yield eth.getCode(receipt.contractAddress);
                        if (!code) {
                            return;
                        }
                        if (code.length > 2) {
                            defer.eventEmitter.emit('receipt', receipt);
                            // if contract, return instance instead of receipt
                            if (extraFormatters && extraFormatters.contractDeployFormatter) {
                                defer.resolve(extraFormatters.contractDeployFormatter(receipt));
                            }
                            else {
                                defer.resolve(receipt);
                            }
                            // need to remove listeners, as they aren't removed automatically when succesfull
                            if (canUnsubscribe) {
                                defer.eventEmitter.removeAllListeners();
                            }
                        }
                        else {
                            utils_1.fireError(new Error("The contract code couldn't be stored, please check your gas limit."), defer.eventEmitter, defer.reject);
                        }
                        if (canUnsubscribe) {
                            sub.unsubscribe();
                        }
                        promiseResolved = true;
                    }
                    // CHECK for normal tx check for receipt only
                    if (!isContractDeployment && !promiseResolved) {
                        if (!receipt.outOfGas &&
                            (!gasProvided || gasProvided !== receipt.gasUsed) &&
                            (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {
                            defer.eventEmitter.emit('receipt', receipt);
                            defer.resolve(receipt);
                            // need to remove listeners, as they aren't removed automatically when succesfull
                            if (canUnsubscribe) {
                                defer.eventEmitter.removeAllListeners();
                            }
                        }
                        else {
                            receiptJSON = JSON.stringify(receipt, null, 2);
                            if (receipt.status === false || receipt.status === '0x0') {
                                utils_1.fireError(new Error('Transaction has been reverted by the EVM:\n' + receiptJSON), defer.eventEmitter, defer.reject);
                            }
                            else {
                                utils_1.fireError(new Error('Transaction ran out of gas. Please provide more gas:\n' + receiptJSON), defer.eventEmitter, defer.reject);
                            }
                        }
                        if (canUnsubscribe) {
                            sub.unsubscribe();
                        }
                        promiseResolved = true;
                    }
                }
                catch (err) {
                    if (!(err instanceof UnminedError)) {
                        utils_1.fireError(err, defer.eventEmitter, defer.reject);
                        return;
                    }
                    timeoutCount++;
                    // check to see if we are http polling
                    if (!!isPolling) {
                        // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second
                        if (timeoutCount - 1 >= POLLINGTIMEOUT) {
                            sub.unsubscribe();
                            promiseResolved = true;
                            utils_1.fireError(new Error('Transaction was not mined within' +
                                POLLINGTIMEOUT +
                                ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);
                        }
                    }
                    else {
                        if (timeoutCount - 1 >= TIMEOUTBLOCK) {
                            sub.unsubscribe();
                            promiseResolved = true;
                            utils_1.fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);
                        }
                    }
                }
            });
        };
        // start watching for confirmation depending on the support features of the provider
        const startWatching = (existingReceipt) => {
            try {
                const sub = eth
                    .subscribe('newBlockHeaders')
                    .on('data', () => {
                    checkConfirmation(existingReceipt, false, sub);
                })
                    .on('error', err => {
                    sub.unsubscribe();
                    promiseResolved = true;
                    utils_1.fireError({ message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.', data: err }, defer.eventEmitter, defer.reject);
                });
            }
            catch (err) {
                if (err.message.includes('does not support subscriptions')) {
                    intervalId = setInterval(() => checkConfirmation(existingReceipt, true), 1000);
                }
                else {
                    throw err;
                }
            }
        };
        // first check if we already have a confirmed transaction
        try {
            const receipt = yield eth.getTransactionReceipt(result);
            if (receipt && receipt.blockHash) {
                if (defer.eventEmitter.listeners('confirmation').length > 0) {
                    // We must keep on watching for new Blocks, if a confirmation listener is present
                    startWatching(receipt);
                }
                checkConfirmation(receipt, false);
            }
            else if (!promiseResolved) {
                startWatching();
            }
        }
        catch (_) {
            if (!promiseResolved)
                startWatching();
        }
    });
}
exports.confirmTransaction = confirmTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlybS10cmFuc2FjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldGgvY29uZmlybS10cmFuc2FjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztFQWVFOzs7QUFFRixvQ0FBcUM7QUFDckMsK0JBQWdDO0FBR2hDLE1BQU0sWUFBWSxHQUFHLEVBQUUsQ0FBQztBQUN4QixNQUFNLGNBQWMsR0FBRyxFQUFFLEdBQUcsWUFBWSxDQUFDLENBQUMsK0NBQStDO0FBQ3pGLE1BQU0sa0JBQWtCLEdBQUcsRUFBRSxDQUFDO0FBRTlCLE1BQU0sWUFBYSxTQUFRLEtBQUs7Q0FBRztBQUVuQyxTQUFzQixrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxHQUFRLEVBQUUsZUFBZ0I7O1FBQ3pGLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztRQUM1QixJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDMUIsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLElBQUksaUJBQWlCLEdBQUcsQ0FBQyxDQUFDO1FBQzFCLElBQUksVUFBVSxHQUFRLElBQUksQ0FBQztRQUMzQixJQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFDckIsSUFBSSxXQUFXLEdBQUcsZUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUN0RyxJQUFJLG9CQUFvQixHQUN0QixlQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFFM0csMkRBQTJEO1FBQzNELElBQUksaUJBQWlCLEdBQUcsVUFBZSxlQUFlLEVBQUUsU0FBUyxFQUFFLEdBQUk7O2dCQUNyRSwwQkFBMEI7Z0JBQzFCLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ1IsR0FBRyxHQUFHO3dCQUNKLFdBQVcsRUFBRTs0QkFDWCxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7d0JBQzVCLENBQUM7cUJBQ0YsQ0FBQztpQkFDSDtnQkFFRCxJQUFJLE9BQU8sR0FBRyxlQUFlLENBQUM7Z0JBRTlCLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ1osSUFBSTt3QkFDRixPQUFPLEdBQUcsTUFBTSxHQUFHLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7cUJBQ25EO29CQUFDLE9BQU8sR0FBRyxFQUFFO3dCQUNaLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQzt3QkFDbEIsZUFBZSxHQUFHLElBQUksQ0FBQzt3QkFDdkIsaUJBQVMsQ0FBQyxFQUFFLE9BQU8sRUFBRSwwQ0FBMEMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7cUJBQ2pIO2lCQUNGO2dCQUVELElBQUk7b0JBQ0YsNkZBQTZGO29CQUM3Rjt3QkFDRSxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRTs0QkFDbEMsTUFBTSxJQUFJLFlBQVksQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO3lCQUM3RDt3QkFFRCx5QkFBeUI7d0JBQ3pCLElBQUksZUFBZSxJQUFJLGVBQWUsQ0FBQyxnQkFBZ0IsRUFBRTs0QkFDdkQsT0FBTyxHQUFHLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQzt5QkFDckQ7d0JBRUQsd0NBQXdDO3dCQUN4QyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7NEJBQzNELEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUMsQ0FBQzs0QkFFcEUsY0FBYyxHQUFHLEtBQUssQ0FBQzs0QkFDdkIsaUJBQWlCLEVBQUUsQ0FBQzs0QkFFcEIsSUFBSSxpQkFBaUIsS0FBSyxrQkFBa0IsR0FBRyxDQUFDLEVBQUU7Z0NBQ2hELGlDQUFpQztnQ0FDakMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO2dDQUNsQixLQUFLLENBQUMsWUFBWSxDQUFDLGtCQUFrQixFQUFFLENBQUM7NkJBQ3pDO3lCQUNGO3FCQUNGO29CQUVELGdDQUFnQztvQkFDaEMsSUFBSSxvQkFBb0IsSUFBSSxDQUFDLGVBQWUsRUFBRTt3QkFDNUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUU7NEJBQzVCLElBQUksY0FBYyxFQUFFO2dDQUNsQixHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7Z0NBQ2xCLGVBQWUsR0FBRyxJQUFJLENBQUM7NkJBQ3hCOzRCQUVELGlCQUFTLENBQ1AsSUFBSSxLQUFLLENBQUMsNERBQTRELENBQUMsRUFDdkUsS0FBSyxDQUFDLFlBQVksRUFDbEIsS0FBSyxDQUFDLE1BQU0sQ0FDYixDQUFDOzRCQUNGLE9BQU87eUJBQ1I7d0JBRUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQzt3QkFDeEQsSUFBSSxDQUFDLElBQUksRUFBRTs0QkFDVCxPQUFPO3lCQUNSO3dCQUVELElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7NEJBQ25CLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzs0QkFFNUMsa0RBQWtEOzRCQUNsRCxJQUFJLGVBQWUsSUFBSSxlQUFlLENBQUMsdUJBQXVCLEVBQUU7Z0NBQzlELEtBQUssQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7NkJBQ2pFO2lDQUFNO2dDQUNMLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7NkJBQ3hCOzRCQUVELGlGQUFpRjs0QkFDakYsSUFBSSxjQUFjLEVBQUU7Z0NBQ2xCLEtBQUssQ0FBQyxZQUFZLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzs2QkFDekM7eUJBQ0Y7NkJBQU07NEJBQ0wsaUJBQVMsQ0FDUCxJQUFJLEtBQUssQ0FBQyxvRUFBb0UsQ0FBQyxFQUMvRSxLQUFLLENBQUMsWUFBWSxFQUNsQixLQUFLLENBQUMsTUFBTSxDQUNiLENBQUM7eUJBQ0g7d0JBRUQsSUFBSSxjQUFjLEVBQUU7NEJBQ2xCLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQzt5QkFDbkI7d0JBQ0QsZUFBZSxHQUFHLElBQUksQ0FBQztxQkFDeEI7b0JBRUQsNkNBQTZDO29CQUM3QyxJQUFJLENBQUMsb0JBQW9CLElBQUksQ0FBQyxlQUFlLEVBQUU7d0JBQzdDLElBQ0UsQ0FBQyxPQUFPLENBQUMsUUFBUTs0QkFDakIsQ0FBQyxDQUFDLFdBQVcsSUFBSSxXQUFXLEtBQUssT0FBTyxDQUFDLE9BQU8sQ0FBQzs0QkFDakQsQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLElBQUksSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLEtBQUssSUFBSSxPQUFPLE9BQU8sQ0FBQyxNQUFNLEtBQUssV0FBVyxDQUFDLEVBQzlGOzRCQUNBLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzs0QkFDNUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzs0QkFFdkIsaUZBQWlGOzRCQUNqRixJQUFJLGNBQWMsRUFBRTtnQ0FDbEIsS0FBSyxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDOzZCQUN6Qzt5QkFDRjs2QkFBTTs0QkFDTCxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUMvQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssS0FBSyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssS0FBSyxFQUFFO2dDQUN4RCxpQkFBUyxDQUNQLElBQUksS0FBSyxDQUFDLDZDQUE2QyxHQUFHLFdBQVcsQ0FBQyxFQUN0RSxLQUFLLENBQUMsWUFBWSxFQUNsQixLQUFLLENBQUMsTUFBTSxDQUNiLENBQUM7NkJBQ0g7aUNBQU07Z0NBQ0wsaUJBQVMsQ0FDUCxJQUFJLEtBQUssQ0FBQyx3REFBd0QsR0FBRyxXQUFXLENBQUMsRUFDakYsS0FBSyxDQUFDLFlBQVksRUFDbEIsS0FBSyxDQUFDLE1BQU0sQ0FDYixDQUFDOzZCQUNIO3lCQUNGO3dCQUVELElBQUksY0FBYyxFQUFFOzRCQUNsQixHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7eUJBQ25CO3dCQUNELGVBQWUsR0FBRyxJQUFJLENBQUM7cUJBQ3hCO2lCQUNGO2dCQUFDLE9BQU8sR0FBRyxFQUFFO29CQUNaLElBQUksQ0FBQyxDQUFDLEdBQUcsWUFBWSxZQUFZLENBQUMsRUFBRTt3QkFDbEMsaUJBQVMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQ2pELE9BQU87cUJBQ1I7b0JBQ0QsWUFBWSxFQUFFLENBQUM7b0JBRWYsc0NBQXNDO29CQUN0QyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUU7d0JBQ2YsNkZBQTZGO3dCQUM3RixJQUFJLFlBQVksR0FBRyxDQUFDLElBQUksY0FBYyxFQUFFOzRCQUN0QyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7NEJBQ2xCLGVBQWUsR0FBRyxJQUFJLENBQUM7NEJBQ3ZCLGlCQUFTLENBQ1AsSUFBSSxLQUFLLENBQ1Asa0NBQWtDO2dDQUNoQyxjQUFjO2dDQUNkLHVHQUF1RyxDQUMxRyxFQUNELEtBQUssQ0FBQyxZQUFZLEVBQ2xCLEtBQUssQ0FBQyxNQUFNLENBQ2IsQ0FBQzt5QkFDSDtxQkFDRjt5QkFBTTt3QkFDTCxJQUFJLFlBQVksR0FBRyxDQUFDLElBQUksWUFBWSxFQUFFOzRCQUNwQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7NEJBQ2xCLGVBQWUsR0FBRyxJQUFJLENBQUM7NEJBQ3ZCLGlCQUFTLENBQ1AsSUFBSSxLQUFLLENBQ1AseUlBQXlJLENBQzFJLEVBQ0QsS0FBSyxDQUFDLFlBQVksRUFDbEIsS0FBSyxDQUFDLE1BQU0sQ0FDYixDQUFDO3lCQUNIO3FCQUNGO2lCQUNGO1lBQ0gsQ0FBQztTQUFBLENBQUM7UUFFRixvRkFBb0Y7UUFDcEYsTUFBTSxhQUFhLEdBQUcsQ0FBQyxlQUFnQixFQUFFLEVBQUU7WUFDekMsSUFBSTtnQkFDRixNQUFNLEdBQUcsR0FBRyxHQUFHO3FCQUNaLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQztxQkFDNUIsRUFBRSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7b0JBQ2YsaUJBQWlCLENBQUMsZUFBZSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDakQsQ0FBQyxDQUFDO3FCQUNELEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLEVBQUU7b0JBQ2pCLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDbEIsZUFBZSxHQUFHLElBQUksQ0FBQztvQkFDdkIsaUJBQVMsQ0FDUCxFQUFFLE9BQU8sRUFBRSxpRkFBaUYsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQ3pHLEtBQUssQ0FBQyxZQUFZLEVBQ2xCLEtBQUssQ0FBQyxNQUFNLENBQ2IsQ0FBQztnQkFDSixDQUFDLENBQUMsQ0FBQzthQUNOO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1osSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFFO29CQUMxRCxVQUFVLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDaEY7cUJBQU07b0JBQ0wsTUFBTSxHQUFHLENBQUM7aUJBQ1g7YUFDRjtRQUNILENBQUMsQ0FBQztRQUVGLHlEQUF5RDtRQUN6RCxJQUFJO1lBQ0YsTUFBTSxPQUFPLEdBQUcsTUFBTSxHQUFHLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDeEQsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtnQkFDaEMsSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO29CQUMzRCxpRkFBaUY7b0JBQ2pGLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDeEI7Z0JBQ0QsaUJBQWlCLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ25DO2lCQUFNLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0JBQzNCLGFBQWEsRUFBRSxDQUFDO2FBQ2pCO1NBQ0Y7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxlQUFlO2dCQUFFLGFBQWEsRUFBRSxDQUFDO1NBQ3ZDO0lBQ0gsQ0FBQztDQUFBO0FBbE9ELGdEQWtPQyJ9