"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const artifacts_1 = require("../internal/artifacts");
const config_env_1 = require("../internal/core/config/config-env");
const errors_1 = require("../internal/core/errors");
const compiler_1 = require("../internal/solidity/compiler");
const compiler_input_1 = require("../internal/solidity/compiler/compiler-input");
const dependencyGraph_1 = require("../internal/solidity/dependencyGraph");
const resolver_1 = require("../internal/solidity/resolver");
const glob_1 = require("../internal/util/glob");
const strings_1 = require("../internal/util/strings");
const task_names_1 = require("./task-names");
const cache_1 = require("./utils/cache");
function default_1() {
    config_env_1.internalTask(task_names_1.TASK_COMPILE_GET_SOURCE_PATHS, async (_, { config }) => {
        return glob_1.glob(path_1.default.join(config.paths.sources, "**/*.sol"));
    });
    config_env_1.internalTask(task_names_1.TASK_COMPILE_GET_RESOLVED_SOURCES, async (_, { config, run }) => {
        const resolver = new resolver_1.Resolver(config.paths.root);
        const paths = await run(task_names_1.TASK_COMPILE_GET_SOURCE_PATHS);
        return Promise.all(paths.map((p) => resolver.resolveProjectSourceFile(p)));
    });
    config_env_1.internalTask(task_names_1.TASK_COMPILE_GET_DEPENDENCY_GRAPH, async (_, { config, run }) => {
        const resolver = new resolver_1.Resolver(config.paths.root);
        const localFiles = await run(task_names_1.TASK_COMPILE_GET_RESOLVED_SOURCES);
        return dependencyGraph_1.DependencyGraph.createFromResolvedFiles(resolver, localFiles);
    });
    config_env_1.internalTask(task_names_1.TASK_COMPILE_GET_COMPILER_INPUT, async (_, { config, run }) => {
        const dependencyGraph = await run(task_names_1.TASK_COMPILE_GET_DEPENDENCY_GRAPH);
        return compiler_input_1.getInputFromDependencyGraph(dependencyGraph, config.solc.evmVersion, config.solc.optimizer);
    });
    config_env_1.internalTask(task_names_1.TASK_COMPILE_RUN_COMPILER)
        .addParam("input", "The compiler standard JSON input", undefined, config_env_1.types.json)
        .setAction(async ({ input }, { config }) => {
        const compiler = new compiler_1.Compiler(config.solc.version, path_1.default.join(config.paths.cache, "compilers"));
        return compiler.compile(input);
    });
    config_env_1.internalTask(task_names_1.TASK_COMPILE_COMPILE, async (_, { config, run }) => {
        const input = await run(task_names_1.TASK_COMPILE_GET_COMPILER_INPUT);
        console.log("Compiling...");
        const output = await run(task_names_1.TASK_COMPILE_RUN_COMPILER, { input });
        let hasErrors = false;
        if (output.errors) {
            for (const error of output.errors) {
                hasErrors = hasErrors || error.severity === "error";
                if (error.severity === "error") {
                    hasErrors = true;
                    console.log("\n");
                    console.error(ansi_colors_1.default.red(error.formattedMessage));
                }
                else {
                    console.log("\n");
                    console.warn(ansi_colors_1.default.yellow(error.formattedMessage));
                }
            }
        }
        if (hasErrors || !output.contracts) {
            throw new errors_1.BuidlerError(errors_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);
        }
        return output;
    });
    config_env_1.internalTask(task_names_1.TASK_BUILD_ARTIFACTS, async (_, { config, run }) => {
        if (await cache_1.areArtifactsCached(config.paths)) {
            console.log("All contracts have already been compiled, skipping compilation.");
            return;
        }
        const sources = await run(task_names_1.TASK_COMPILE_GET_SOURCE_PATHS);
        if (sources.length === 0) {
            console.log("No Solidity source files available.");
            return;
        }
        const compilationOutput = await run(task_names_1.TASK_COMPILE_COMPILE);
        if (compilationOutput === undefined) {
            return;
        }
        await fs_extra_1.default.ensureDir(config.paths.artifacts);
        let numberOfContracts = 0;
        for (const file of Object.values(compilationOutput.contracts)) {
            for (const [contractName, contractOutput] of Object.entries(file)) {
                const artifact = artifacts_1.getArtifactFromContractOutput(contractName, contractOutput);
                numberOfContracts += 1;
                await artifacts_1.saveArtifact(config.paths.artifacts, artifact);
            }
        }
        console.log("Compiled", numberOfContracts, strings_1.pluralize(numberOfContracts, "contract"), "successfully");
    });
    config_env_1.task(task_names_1.TASK_COMPILE, "Compiles the entire project, building all artifacts", async (__, { run }) => run(task_names_1.TASK_BUILD_ARTIFACTS));
}
exports.default = default_1;
//# sourceMappingURL=compile.js.map