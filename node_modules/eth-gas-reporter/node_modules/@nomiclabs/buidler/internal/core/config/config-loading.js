"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const context_1 = require("../../context");
const plugins_1 = require("../plugins");
const project_structure_1 = require("../project-structure");
const config_resolution_1 = require("./config-resolution");
function importCsjOrEsModule(filePath) {
    const imported = require(filePath);
    return imported.default !== undefined ? imported.default : imported;
}
function loadConfigAndTasks(configPath) {
    if (configPath === undefined) {
        configPath = project_structure_1.getUserConfigPath();
    }
    else {
        if (!path.isAbsolute(configPath)) {
            configPath = path.join(process.cwd(), configPath);
            configPath = path.normalize(configPath);
        }
    }
    // Before loading the builtin tasks, the default and user's config we expose
    // the config env in the global object.
    const configEnv = require("./config-env");
    const globalAsAny = global;
    Object.entries(configEnv).forEach(([key, value]) => (globalAsAny[key] = value));
    // This is a horrible hack that deserves an explanation.
    //   - config files can execute the usePlugin function, which is imported
    //     from config.ts.
    //   - There's no way to pass it arguments.
    //   - Internally, usePlugin calls require, which should use the same
    //     node_module's paths than the Buidler project.
    //   - Except that it doesn't when we are linking Buidler for local tests.
    //   - node resolves symlinks before loading modules, so imports from
    //     Buidler files are run in this context, not inside the Buidler project.
    //   - We solve this by using require.resolve and specifying the paths,
    //     but we need the config path in order to do so.
    //   - We set the config path into the BuidlerContext and cry a little ðŸ˜¢
    const ctx = context_1.BuidlerContext.getBuidlerContext();
    ctx.configPath = configPath;
    plugins_1.loadPluginFile(__dirname + "/../tasks/builtin-tasks");
    const defaultConfig = importCsjOrEsModule("./default-config");
    const userConfig = importCsjOrEsModule(configPath);
    // To avoid bad practices we remove the previously exported stuff
    Object.keys(configEnv).forEach(key => (globalAsAny[key] = undefined));
    return config_resolution_1.resolveConfig(configPath, defaultConfig, userConfig);
}
exports.loadConfigAndTasks = loadConfigAndTasks;
//# sourceMappingURL=config-loading.js.map