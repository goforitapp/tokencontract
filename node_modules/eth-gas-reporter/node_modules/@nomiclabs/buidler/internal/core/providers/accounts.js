"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const account_1 = require("web3x/account");
const errors_1 = require("../errors");
const wrapper_1 = require("./wrapper");
const HD_PATH_REGEX = /^m(:?\/\d+'?)+\/?$/;
function createLocalAccountsProvider(provider, privateKeys) {
    const { bufferToHex, toBuffer } = require("ethereumjs-util");
    const accounts = privateKeys.map(pkString => account_1.Account.fromPrivate(toBuffer(pkString)));
    return wrapper_1.wrapSend(provider, async (method, params) => {
        if (method === "eth_accounts" || method === "eth_requestAccounts") {
            return accounts.map(acc => acc.address.toLowerCase());
        }
        if (method === "eth_sign") {
            const [address, data] = params;
            if (address !== undefined) {
                if (data === undefined) {
                    throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.ETHSIGN_MISSING_DATA_PARAM);
                }
                const account = accounts.find(acc => acc.address.toLowerCase() === address.toLowerCase());
                if (account === undefined) {
                    throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.NOT_LOCAL_ACCOUNT, address);
                }
                return account.sign(data).signature;
            }
        }
        if (method === "eth_sendTransaction" && params.length > 0) {
            const tx = params[0];
            if (tx.chainId === undefined) {
                throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.MISSING_TX_PARAM_TO_SIGN_LOCALLY, "chainId");
            }
            if (tx.gas === undefined) {
                throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.MISSING_TX_PARAM_TO_SIGN_LOCALLY, "gas");
            }
            if (tx.gasPrice === undefined) {
                throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.MISSING_TX_PARAM_TO_SIGN_LOCALLY, "gasPrice");
            }
            if (tx.nonce === undefined) {
                tx.nonce = await provider.send("eth_getTransactionCount", [
                    tx.from,
                    "pending"
                ]);
            }
            const account = accounts.find(acc => acc.address.toLowerCase() === tx.from.toLowerCase());
            if (account === undefined) {
                throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.NOT_LOCAL_ACCOUNT, tx.from);
            }
            const { default: Transaction } = await Promise.resolve().then(() => __importStar(require("ethereumjs-tx")));
            const transaction = new Transaction(tx);
            transaction.sign(account.privateKey);
            return provider.send("eth_sendRawTransaction", [
                bufferToHex(transaction.serialize())
            ]);
        }
        return provider.send(method, params);
    });
}
exports.createLocalAccountsProvider = createLocalAccountsProvider;
function createHDWalletProvider(provider, mnemonic, hdpath = "m/44'/60'/0'/0/", initialIndex = 0, count = 10) {
    if (hdpath.match(HD_PATH_REGEX) === null) {
        throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.INVALID_HD_PATH, hdpath);
    }
    if (!hdpath.endsWith("/")) {
        hdpath += "/";
    }
    const accounts = [];
    for (let i = initialIndex; i < initialIndex + count; i++) {
        accounts.push(account_1.Account.createFromMnemonicAndPath(mnemonic, hdpath + i.toString()));
    }
    const { bufferToHex } = require("ethereumjs-util");
    return createLocalAccountsProvider(provider, accounts.map(account => bufferToHex(account.privateKey)));
}
exports.createHDWalletProvider = createHDWalletProvider;
function createSenderProvider(provider, from) {
    let addresses = from === undefined ? undefined : [from];
    return wrapper_1.wrapSend(provider, async (method, params) => {
        if (method === "eth_sendTransaction" || method === "eth_call") {
            const tx = params[0];
            if (tx !== undefined && tx.from === undefined) {
                const [senderAccount] = await getAccounts();
                if (senderAccount !== undefined) {
                    tx.from = senderAccount;
                }
                else if (method === "eth_sendTransaction") {
                    throw new errors_1.BuidlerError(errors_1.ERRORS.NETWORK.NO_REMOTE_ACCOUNT_AVAILABLE);
                }
            }
        }
        return provider.send(method, params);
    });
    async function getAccounts() {
        if (addresses !== undefined) {
            return addresses;
        }
        addresses = (await provider.send("eth_accounts"));
        return addresses;
    }
}
exports.createSenderProvider = createSenderProvider;
//# sourceMappingURL=accounts.js.map